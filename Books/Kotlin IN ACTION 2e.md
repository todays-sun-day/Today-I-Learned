# 👩‍💻 Kotlin IN ACTION 2/e
저자: 세바스티안 아이그너, 로만 엘리자로프, 스베트라나 이사코바, 드미트리 제메로프  
옮긴이: 오현석  
출판사: 에이콘

---

## 들어가며
#### pg.31
자바를 대신할 만한 언어를 찾을 수 없었다. 
우리가 자바를 대신할 언어에 대해 어떤 요구 사항을 갖고 있었을까?  

처음이자 가장 분명한 요구 사항은 **정적 타입 지정(static typing)** 이었다. 
정적 타입 지정 외에 수백만 줄이나 되는 코드 기반을, 미치지 않고 개발할 수 있는 다른 방법은 없다. 
둘째로 기존 자바 코드와 완전히 호환되는 언어가 필요했다. 
기존 코드베이스는 젯브레인즈의 엄청나게 귀중한 자산이며 상호운용성이 부족해서 그런 자산을 잃어버리거나 자산의 가치가 줄어드는 일을 용납할 수는 없었다. 
셋째로 우리는 도구 제공 가능성을 타협하고 싶지 않았다. 
회사로서 젯브레인즈에게 가장 중요한 가치는 개발 생산성이며, 높은 생산성을 얻으려면 훌륭한 도구가 필수다. 
마지막으로 배우기 쉽고 코드에 대해 추론하기 쉬운 언어가 필요했다.

---

## 이 책에 대해
#### pg.32
이 책은 독자에게 코틀린 언어를 가르쳐주고 코틀린을 사용해 자바 가상머신과 안드로이드에서 실행되는 애플리케이션을 작성하는 방법을 알려준다.

---

## 1. 코틀린이란 무엇이며, 왜 필요한가?
### 1.2 코틀린의 주요 특성
#### pg.44
코틀린은 **정적 타입 지정 언어**인데, 이는 실행 시점이 아니라 컴파일 시점에 많은 오류를 잡아낼 수 있다는 뜻이다.

#### pg.45
코틀린을 활용할 수 있는 가장 일반적인 영역은 다음과 같다.
- 안드로이드 디바이스에서 실행되는 모바일 애플리케이션
- 서버상의 코드 (특히 웹 애플리케이션의 백엔드)

#### pg.46
다음은 정적 타입 지정의 몇 가지 장점이다.
- 성능: 어떤 메서드를 호출해야 할지를 런타임에 살펴볼 필요가 없기 때문에 메서드 호출이 더 빠르다.
- 신뢰성: 컴파일러가 타입을 사용해 프로그램의 일관성을 검증하며, 그로 인해 실행 시점에 프로그램이 실패할 가능성이 줄어든다.
- 유지 보수성: 코드가 작용하는 타입을 볼 수 있기 때문에 낯선 코드를 다룰 때도 더 쉽게 다룰 수 있다.
- 도구 지원: 정적 타입 지정을 사용하면 리팩터링의 신뢰도를 높일 수 있고 코드 완성이나 다른 IDE 기능의 정확도를 높일 수 있다.

#### pg.47
컴파일러가 문맥을 고려해 변수 타입을 결정하는 이런 기능을 **타입 추론**이라 부른다.

여러분의 눈길을 끄는 특성으로 코틀린이 **널이 될 수 있는 타입(nullable type)** 을 지원한다는 점을 들 수 있다. 
널이 될 수 있는 타입을 지원함에 따라 런타임에 프로그램이 망가지면서 끝나는 대신, **널 포인터 예외(null pointer exception)** 가 발생하는지 여부를 컴파일 시점에 검사할 수 있어서 좀 더 프로그램의 신뢰성을 높일 수 있다.

#### pg.48
함수형 프로그램의 핵심 개념은 다음과 같다.
- 일급 시민인 함수: 함수를 일반 값처럼 다룰 수 있다. 함수를 변수에 저장할 수 있고, 함수를 인자로 다른 함수에 전달할 수 있으며, 함수에서 새로운 함수를 만들어 반환할 수 있다.
- 불변성: 함수형 프로그래밍에서는 일단 만들어지고 나면 내부 상태가 절대로 바뀌지 않는 불변 객체를 사용해 프로그램을 작성한다.
- 부수 효과 없음: 함수형 프로그래밍에서는 입력이 같으면 항상 같은 출력을 내놓고 다른 객체의 상태를 변경하지 않으며 함수 외부나 다른 바깥 환경과 상호작용하지 않는 순수 함수를 사용한다.

#### pg.51
동시성 처리에는 스레드로부터 콜백, 퓨처와 프라미스, 반응형 확장 등의 다양한 접근 방법이 있었다.  
코틀린은 동시성과 비동기 프로그래밍의 문제를 코루틴이라 불리는 일시 중단 가능한 계산을 사용해 접근한다.

#### pg.52
또 코루틴은 아주 가벼운 추상화인데, 이는 큰 성능 손해를 보지 않고 수백만 개의 동시성 작업을 시작할 수 있다는 뜻이다.

### 1.3 코틀린이 자주 쓰이는 분야
#### pg.57
DSL은 코틀린 언어 특성을 유연하게 조합하며 설정, 복잡한 객체 생성, 객체 관계 매핑 작업, 객체를 데이터베이스 표현으로 변환하거나 역방향으로 변환하기 등에 자주 사용된다.

#### pg.59
예를 들어 구글도 자신의 '구글 홈' 앱에서 새로운 기능 개발을 코틀린으로 전환 후 NullPointerException으로 인한 프로그램 중단 횟수를 30% 줄일 수 있었다.

코틀린은 자바 8 이상과 완전히 호환되며, 코틀린 컴파일러가 생성한 바이트코드도 효율적으로 실행된다.

---

## 2. 코틀린 기초

### 2.1 기본 요소: 함수와 변수
#### pg.77
함수를 모든 코틀린 파일의 최상위 수준에 정의할 수 있으므로 클래스 안에 함수를 넣어야 할 필요는 없다.

코틀린 표준 라이브러리는 수많은 표준 자바 라이브러리 함수에 대해 더 간결한 구문을 사용할 수 있게 해주는 래퍼(wrapper)를 제공한다. 
`println`도 그런 래퍼 중 하나다.

#### pg.79
어떤 경우든 `main` 함수는 아무 값도 반환하지 않는다.

식은 값을 만들어내며 다른 식의 하위 요소로 계산에 참여할 수 있는 반면, 문은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어내지 않는다는 차이가 있다.

#### pg.81
본문이 중괄호로 둘러싸인 함수를 **블록 본문 함수**(block body function)라 부르고, 등호와 식으로 이뤄진 함수를 **식 본문 함수**(expression body function)라고 부른다.

#### pg.82
식 본문 함수의 경우 굳이 사용자가 반환 타입을 적지 않아도 컴파일러가 함수 본문 식을 분석해서 결과 타입을 함수 반환 타입으로 정해준다. 
이런 분석을 **타입 추론**(type inference)이라 부른다.

명시적으로 함수의 반환 타입을 지정하면 실수로 함수 시그니처가 바뀌면서 라이브러리 소비자들의 코드에 오류가 발생하는 경우를 피할 수 있다.

#### pg.83
변수를 선언하면서 즉시 초기화하지 않고 나중에 값을 대입하고 싶을 때는 컴파일러가 변수 타입을 추론할 수 없다. 
이런 경우에는 명시적으로 변수의 타입을 지정해야 한다.

#### pg.84
기본적으로 코틀린에서 모든 변수를 `val` 키워드를 사용해 선언하는 방식을 지켜야 한다. 
반드시 필요할 때에만 변수를 `var`로 변경한다.

#### pg.85
`val` 참조 자체가 읽기 전용이어서 한 번 대입된 다음에 그 값을 바꿀 수 없더라도 그 참조가 가리키는 객체의 내부 값은 변경될 수 있다는 사실을 기억하자.

`var` 키워드를 사용하면 변수의 값을 변경할 수 있지만 변수의 타입은 고정된다.

### 2.2 행동과 데이터 캡슐화: 클래스의 프로퍼티
#### pg.92
코틀린의 `name` 프로퍼티는 자바 측에게 `getName`이라는 이름으로 노출된다. 게터와 세터의 이름을 정하는 규칙에는 예외가 있다. 
이름이 `is`로 시작하는 프로퍼티의 게터에는 `get`이 붙지 않고 원래 이름을 그대로 사용하며, 세터에는 `is`를 `set`으로 바꾼 이름을 사용한다. 
따라서 자바에서 `isStudent` 프로퍼티에 접근할 때는 `isStudent()`와 `setStudent()`를 사용해야 한다.

#### pg.93
프로퍼티 값을 저장하지 않고 계산: 커스텀 접근자

#### pg.94
커스텀 게터를 정의하는 방식과 클래스 안에 파라미터가 없는 함수를 정의(코틀린에서는 멤버 함수나 메서드라고 부름)하는 방식 중 어느 쪽이 더 나은지 질문하는 독자도 있을 것이다. 
두 방식 모두 비슷하다. 
구현이나 성능 차이는 없다.

일반적으로 클래스의 특성(프로퍼티는 특성이라는 뜻이 있다)을 기술하고 싶다면 프로퍼티로 그 특성을 정의해야 한다. 
클래스의 행동을 기술하고 싶다면 프로퍼티가 아니라 멤버 함수를 선택한다.

#### pg.96
코틀린은 클래스 임포트와 함수 임포트를 구분하지 않고 `import` 키워드로 모든 종류의 선언을 임포트할 수 있게 해준다.

패키지 이름 뒤에 `.*`를 추가하면 패키지 안의 모든 선언을 임포트할 수 있다.

스타 임포트를 와일드카드(wildcard) 임포트라고도 부른다.


